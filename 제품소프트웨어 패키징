1. 소프트웨어 패키징
기능별로 실행 파일들을 묶어서 설치 파일 만듦
- 사용자 중심
- 향후 관리 위해 모듈화(Modularity)
고려사항
- 필요 최소한의 시스템 환경(OS, CPU, 메모리 등)
- UI(User Interface)를 직접 확인할 시각 자료와 제공
- Managed Service(소프트웨어 사용을 24시간 모니터링하는 등 유지 보수 수행) 제공 권장
- 편의성 고려한 안정적 배포 중요
- 요구사항 반영한 변경 및 개성 항시 고려
작업 순서
- 애자일 기법: 2-4주 내의 주기로 패키징 수행
- 패키징 결과물 테스트 서버에 배포
- 최종 결과물은 온라인(별도 운영 서버에 매뉴얼과 함께 파일 등록)/오프라인(CD-ROM 등) 배포
기능 식별: 코드의 기능 확인
모듈화: 기능 단위로 코드 분류
빌드 진행: 모듈 별로 실행 파일
사용자 환경 분석: 사용 환경(웹/모바일/PC 등), 운영체제(인도우/유닉스/안드로이드 등), CPU, RAM
패키징 및 적용 시험: 빌드한 파일을 배포용 파일 형식으로 패키징하고 테스팅
패키지 변경 개선: 적용 시험 후 확인된 불편 사항 반영
배포: 오류 발생 시 개발자에게 전달 및 수정 요청


2. 릴리즈 노트
Release Note
- 사용자에게 제공하는 소프트웨어에 대한 문서(개발 과정에서 정리된 릴리즈 정보 공유)
- 테스트 진행 방법에 대한 결과/소프트웨어 사양에 대한 준수 확인
- 버전 관리를 체계적 관리
- 초기 배포 혹은 추가 배포시 제공
- 철저한 테스트 후 소프트웨어 사양에 대한 최종 승인 얻어 문서화
고려 사항
초기 버전 작성시
- 개발팀이 현재 시제로
- 신규 소스, 빌드, 개선 항목 등의 이력
- Header(머리말) / 개요 / 목적 / 문제 요약 / 재현 항목 / 수정 및 개선 내용 / 사용자 영향도 / SW 지원 영향도 / 노트 / 면책 조항(프리웨어, 불법 복제 금지 등) / 연락처
추가 버전 작성시
- 베타 버전 출시나 긴급 버그 수정, 업그레이드 등의 경우
- 버그 번호 포함 모든 수정 내용 릴리즈 노트에 작성


3. DRM
디지털 저작권 관리(Digital Right Management)
- 소프트웨어 안전 유통을 위한 디지털 콘텐츠 관리/보호 기술
- 원본이 아날로그이면 디지털로 변환 후 패키저(Packager)로 패키징
- 콘텐츠 크기가 작으면 사용자가 요청 시 실시간 패키징
- 크면 미리 패키징 후 배포
- 패키징 후 콘텐츠에 암호화된 저작권자의 전자서명 포함
- 클리어링 하우스(Clearing House)에 등록된 라이선스 정보로 사용자 인증 및 사용 권한 여부 확인
- 종량제 방식의 경우 실제 사용량에 따라 요금 부과
클리어링 하우스: 저작권의 사용 권한 정책, 라이선스 발급, 사용량에 따른 결제 관리
콘텐츠 제공자(Contents Provider): 저작권자
패키저: 콘텐츠에 대한 속성 정보를 설명하는 메타 데이터(Meta Data)와 함께 묶어 암호화하는 프로그램
콘텐츠 분배자(Contents Distributor): 콘텐츠 유통 시스템
콘텐츠 소비자(Customer): 구매하여 사용하는 주체
DRM 컨트롤러(Controller): 배포 후 이용 권한 통제하는 프로그램
보안 컨테이너(Security Container): 원본의 안전 유통을 위한 전자 보안 장치


4. 소프트웨어 설치 매뉴얼
사용자가 구매 후 설치하는 과정에서 필요한 내용을 기록한 설명서와 안내서
- 사용자 기준
- 시작부터 완료 시까지의 모든 과정에 대한 내용이 순서대로 수록
- 설치 과정에서 나타날 수 있는 오류 메시지/예외 상황을 별도로 분류하여 설명
- 목차/개요, 서문, 기본 사항 등을 포함
- 설치 과정 요약한 내용을 목차의 관련 내용 시작 페이지에 기술
- 매뉴얼 개요에 주요 특징, 구성, 설치 방법, 순서 등


5. 소프트웨어 사용자 매뉴얼
설치 후 사용 과정에서 필요한 절차, 환경 등 필요한 제반 사항을 모두 작성한 설명서와 안내서
- 배포 후 발생할 수 있는 오류에 대한 패치(Patch) 및 기능에 대한 업그레이드를 위해 메뉴얼 버전 관리
- 개별 동작하는 컴포넌트(Component) 단위로 작성
- 컴포넌트 명세서(개요, 내부 클래스 동작, 외부 통신 명세 등)와 컴포넌트 구현 설계서(구조도, 목록, 컴포넌트 명세, 인터페이스 명세)를 바탕으로
- 목차/개요, 서문, 기본 사항 등 포함
- 매뉴얼 전체 내용을 요약하여 목차의 관련 내용 시작페이지를 함께 기술
- 소프트웨어 주요 특징, 매뉴얼의 구성 및 실행 방법, 사용법, 항목별 점검 기준, 항목별 설정 방법 등


6. 형상 관리
SCM; Software Configuration Management(버전 관리)
- 소프트웨어 개발 과정에서 코드와 라이브럴, 관련 문서 등의 버전을 관리하고 변경 사항을 지속 관리하는 일련의 활동
- 변경 원인을 제어하고, 변경 내역을 담당자에게 통보
- 개발 전 단계에 적용되고 유지보수 시에도 수행
- 전체 비용 줄이고, 방해 요인 최소화 보증을 목적
중요성
- 지속적 변경 사항을 체계적으로 통제
- 무절제한 변경 방지
- 버그/수정 사항 추적
- 가시성(Visibility)이 없는 소프트웨어의 개발 진행 정도를 파악하는 기준
기능: 품질 보증
- 형상 식별: 관리 대상에 이름/번호 부여, 계층(Tree) 구조로 구분
- 버전 제어: 버전의 형상 항목 관리, 특정 절차/도구(Tool) 결합
- 형상 통제(변경 관리): 식별 항목에 대한 변경 요구 검토하여 현 기준선(Base Line)이 반영되도록 조정
- 형상 감사: 기준선(변경 통제 시점)의 무결성 평가 후 공식 승인
- 형상 기록(상태 보고): 전 과정의 결과를 기록/관리, 보고서 작성
주요 용어
- 저장소(Repository): 최신 버전 파일과 변경 내역이 저장
- 가져오기(Import): 빈 저장소에 처음으로 파일 복사
- 체크아웃(Check-Out): 저장소에서 파일 받아옴
- 체크인(Check-In): 파일 수정 후 저장소에 새로운 버전으로 갱신
- 커밋(Commit): 체크인 시 이전 갱신 내용 있으면 충돌(Conflict) 알리고 diff 도구로 수정 후 완료
- 동기화(Update): 저장소의 최신 버전으로 작업 공간 업데이트
7. Subversion


SVN(서브버전)
- CVS(Current Version System)의 단점(디렉터리 이름 변경/이동) 개선한 아파치의 무료 형상 관리 도구
- 클라이언트/서버(저장소) 구조
- trunk 디렉터리에서 모든 개발 작업 수행
- branches 디렉터리 내의 별도 디렉터리에서 추가 작업 완료 후 trunk 디렉터리와 병합(merge)
- 커밋 시 리비전(Revision) 1 증가(저장소 생성 시 0)
- 주로 유닉스 서버
주요 명령어
- add, commit, update, checkout, lock/unlock, import, export, info, diff, merge


8. Git
깃
- 분산 버전 관리 시스템(하나의 원격 저장소와 분산된 로컬 저장소에 함께 저장 관리)
- 지역 저장소에서 실제 개발 및 버전 관리 신속 수행(원격 저장소/네트워크에 문제 있어도 작업 가능)
- 협업으로 원격 저장소에서 버전 공동 관리(로컬의 관리 내역 반영, 다른 개발자의 변경 내용 가져옴)
- 토픽(Topic) 브랜치/피처(Feature) 브랜치로 마스터(Master) 브랜치에 영향 없이 다양한 테스팅 가능
- 이전의 포인터(Pointer)를 가지는 스냅샷(Snapshot)으로 파일 변화 저장
주요 명령어
- add, commit, branch, checkout, merge, init, remote add, push, fetch, clone, fork


9. Jenkins
JAVA 기반 오픈 소스 빌드 자동화 도구(가장 많이 사용)
- 서블릿(Suver Side Applet) 컨테이너에서 실행되는 서버 기반
- 형상 관리 도구(SVN, Git 등)와 연동
- Web GUI
- 여러 컴퓨터 이용한 분산 빌드/테스트 가능


10. Gradle
Groovy(동적 객체 지향 프로그래밍 언어) 기반 오픈 소스 빌드 자동화 도구
- 안드로이드 앱 개발 시 사용
- 플로그인 설정하면 JAVA, C, C++, Python 등으로 빌드 가능
- Groovy로 만든 DSL(Domain Specific Language)을 스크립트 언어(Script Language)로 사용
- 처리 명령을 모은 태스크(Task) 단위로 실행
- 이전 태스크 재사용하거나 타 시스템 태스크 공유하는 빌드 캐시 기능으로 속도 향상
