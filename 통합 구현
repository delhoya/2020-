1. 단위 기능 명세서
설계 과정에서 단위 기능을 명세화한 문서
- 추상화: 복잡한 시스템을 단순히 구현
- 구조화: 시스템을 분해하여 단위 기능별로 구분하고 계층적으로 구성
- 정보 은닉: 단위 모듈(Unit Module)의 독립적 운용과 다른 모듈의 접근/변경 막도록 고려


2. IPC
Inter-Process Communication
- 모듈 간 통신 방식을 구현하는 프로그래밍 인터페이스 집합
- 복수 프로세스 수행시 이루어지는 프로세스 간 통신 구현
Shared Memory: 다수 프로세스가 공유 메모리 구성하여 통신
Socket: 네트워크 소켓 이용하여 경유 프로세스 간 통신
Semaphores: 공유 자원에 대한 접근 제어
Pipes & named Pipes: 파이프(선입선출)로 구성된 메모리를 프로세스 간 공유하고 한 파이프가 이용 중이면 다른 프로세스 접근 못함
Message Queueing: 메시지 발생 시 전달


3. 테스트 케이스
Test Case
- 명세 기반 테스트의 설계 산출물로 모듈이 제대로 작성되었는지 확인하기 위해 입력될 수 있는 값들과 예상 결과를 나열한 목록의 명세서
- 단위 모듈 테스트(Unit Test)를 하기 전에 만듦
- 테스트 케이스를 이용하지 않는 직관적 테스트는 검증 누락/반복으로 인한 인력/시간 낭비 우려
식별자(Identifier): 항목, 일련번호
테스트 항목(Test Item): 대상(모듈/기능)
입력 명세(Input Specification): 데이터 또는 테스트 조건
출력 명세(Output Specification): 수행시 기대 출력 결과
환경 설정(Envirionmental Needs): 필요 하드웨어/소프트웨어 환경
특수 절차 요구(Special Procedure Requirement): 특별 요구 절차
의존성 기술(Inter-case Dependencies): 테스트 케이스 간 의존성


4. 단위 모듈 테스트
Unit Test
- 프로그램의 단위 기능 구현 모듈이 정해진 기능을 정확히 수행하는지 검증
화이트박스 테스트: 소스 코드 오픈 상태에서 논리적 경로 테스트
블랙박스 테스트: 소프트웨어의 특정 기능이 완전히 작동하는지 입증
모듈 단독 실행 환경과 테스트에 필요한 데이터 준비돼야
통합 후 오래 추척해야 발견할 에러를 단위 모듈 테스트로 쉽게 수정
시스템 수준 오류는 못잡음


5. 테스트 프로세스
테스트 시 수행하는 모든 작업이 목적과 조건을 달성해야
5단계
1. 계획 및 제어: 계획 수립 후 그대로 진행되도록 제어
2. 분석 및 설계: 목표를 구체화하여 테스트 케이스와 적용 순서대로 묶어 명세한 테스트 시나리오(Test Scenario) 작성
3. 구현 및 실현: 테스트 케이스의 실행 순서인 테스트 프로시저(Test Procedure)/테스트 스크립트(Test Script)를 명세하고 모듈의 환경에 맞는 단위 테스트 도구 이용하여 수행
4. 평가: 테스트가 계획과 목표대로 수행되었는지 평가 및 기록
5. 완료: 수행 증거자료와 차후 테스트를 위한 참고자료로 쓰기 위해 수행 과정과 산출물 기록/저장


6. IDE
Integrated Development Environment(통합 개발 환경)
- 편집기(Editor), 컴파일러(Compiler), 디버거(Debugger) 등을 하나의 인터페이스로 제공하는 소프트웨어
코드 자동 생성 혹은 컴파일(Compile)
툴 다운로드하여 추가
코드 실행 및 테스트 시 발생 오류를 시각화
외부 서비스(배포/버전 관리/오픈소스 커뮤니티)와 연동
플랫폼, 운영체제, 언어별로 다양
- 대표적 도구
이클립스(Eclipse)
비주얼 스튜디오(Visual Studio)
엑스 코드(Xcode)
안드로이드 스튜디오(Android Studio)
IDEA


7. 빌드 도구
소스 코드 파일을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로의 변환 과정에 필요한 전처리, 컴파일 등 수행
- Preprocessing: 컴파일 전 코드의 주석, 매크로 등 처리


8. 단위 모듈
Unit Module
- 소프트웨어에 필요한 동작들 중 하나의 기능(단위 기능)만을 구현한 모듈
- 두 모듈이 합쳐지면 두 기능 구현
- 전달받은 값으로 시작하는 작은 프로그램
- 처리문, 명령문, 데이터 구조 등으로 구성
- 독립적으로 컴파일 가능
- 다른 모듈로 호출되거나 삽입 가능
- 단위 기능 명세서 작성하고 입/출력 기능과 알고리즘 구현
입/출력 기능
데이터 형식에 따라 단위 모듈 간 연동/통신을 위한 데이터 구현
CLI(Command Line Interface), GUI(Graphical User Interface)와의 연동 고려
Open source API로 네트워크나 외부 장치와의 입/출력 간단 구현
알고리즘 구현
단위 기능별 요구사항을 구현 가능한 언어로
사용자 요구와 일치하는지 확인 필요
디바이스 드러이버 모듈, 네트워크 모듈, 파일 모듈, 메모리 모듈, 프로세스 모듈


9. Ant
Another Neat Tool
- 아파치 소프트웨어 재단(Apache Software Foundation)의 자바 프로젝트 공식 빌드 도구
XML 기반 빌드 스크립트 사용
자유도와 유연성 높아 복잡한 빌드 환경에 대처
개발자가 모든 규칙과 표준 정의
스크립트 재사용 어려움
10. Maven
Ant의 대안으로 아파치에서 개발
규칙과 표준 존재
예외사항만 기록
컴파일과 빌드 동시 수행
의존성(Dependency) 설정하여 라이브러리(Library) 관리





1. SOA (Service Oriented Architecture)란?
 
기존의 애플리케이션들의 기능들을 비즈니스적인 의미를 가지는 기능 단위로 묶어서 표준화된
호출 인터페이스를 통해서 서비스라는 소프트웨어 컴포넌트 단위로 재조합한 후, 이 서비스들을
서로 조합(Orchestration)하여 업무 기능을 구현한 애플리케이션을 만들어내는 소프트웨어 아키텍처.
 
 - 기존의 시스템이 각각의 독립된 업무 시스템으로 개발되었던 반면 SOA는 기업의 전체 업무가
 하나의 거대한 SOA시스템으로 구성이 된다.
 
  => 각각의 시스템의 기능들을 업무 기준으로 주요 기능들로 묶어서 플랫폼에 독립적인
  인터페이스(예를 들어 XML/HTTP, CORBA, SOAP)를 구현하여 외부로 서비스를 제공한다.
 
 
 2. SOA의 기본적인 개념
 
  새로운 업무를 구현할 때 새롭게 시스템을 신규 개발하는 것이 아니라 이미 제공되어 있는
  기존의 서비스들을 조합하여 하나의 업무를 구현할 수 있다.
 
  소프트웨어의 재사용성과 레고웨어 의 연장선..
 
  급격한 비즈니스 환경의 변화에 따라 비즈니스 요구를 민첩하게 IT시스템에 반영해야 하는
  필요성이 생겼고, 각 업무별로 독립된 시스템의 형태로 개발되어 있는 업무 시스템들을
  통합하기 위해 SOA가 대두되었다.
 
  SOA는 "서비스와 이를 조합하여 애플리케이션을 구성하는 것"
 
 
 
  * "서비스"와 서비스를 구성하는 방법"?
  - 서비스란?
    플랫폼에 종속되지 않는 표준 인터페이스(CORBA나 웹서비스)를 통해서 기업의 업무를 표현한
    Loosely Coupled하고 상호 조합 가능한 소프트웨어!
 
    현대의 SOA에서 서비스의 플랫폼 종속성은 SOAP 기반의 웹서비스 또는 XML을 통해서 구현된다.
    서비스를 표현하는데 있어서 가장 중요한 특징은 "기업의 업무를 표현한다"는 것.
 
  - 서비스 구성
    . 서비스 인터페이스 : EJB나 Java Object의 비즈니스 메서드
    . 서비스 규약 : 서비스를 사용하기 위한 규약, 데이터 포맷, 변수형 서비스를 호출하기 위한 인자,
                         인터페이스 이름 등의 정의되는 Contract
    . 서비스의 구현체 : Implementation
 
    현대의 SOA에서는 대부분이 웹서비스를 표준 인터페이스로 사용하기 때문에 서비스 Contract는
    WSDL로 정의된다.
 
  - Application frontend
   최종 사용자에게 보이는 곳. 일반적인 웹사이트, 기업 포탈, X-인터넷 클라이언트, 4GL클라이언트, ajax, flex 등
 
 
 
 
 
  * SOA 아키텍처
  - Fundamental SOA : 가장 큰 목적은 시스템을 각각 서비스화 하는 것과 독립되었던 시스템을
   통합하여 하나의 시스템으로 운영한다는데 목적.
 
   . 서비스화 : 서비스 인터페이스로 대부분 SOAP기반의 웹서비스를 사용. 솔루션 중에는 이러한 웹서비스를 제공하는
 
     서비스 아답터가 제공된다. (SAP, Siebel아답터, SALT 등)
 
  - Networked SOA (유연성과 통제 추가) : 서비스화해서 통합한 SOA시스템은 시간이 지날수록 덩치가 커진다.
 
   그에 따라 서비스간 호출 관계는 더 복잡해지게 되며, 서비스 내용이 변경됨에 따라 서로 간의 의존성에 의해서
 
   서비스 간의 수정이 필요하게 된다. 이렇게 되면서 서비스의 변화가 더 어려워지게 되는데 결과적으로 업무에 대해
 
   "경직성"을 유발하게 된다. 이것을 해결하기 위해서 모든 서비스들을 중앙에 하나의 버스를 두고 그를 통해 관리함으로써
 
   서비스간 연결의 복잡도를 해소한다. 이 버스가 바로 ESB(Enterprise Service Bus)! ESB는 서비스에 대한 모니터링과
 
   Intermediary 서비스 기능의 제공, 위치에 대한 투명성을 제공한다.
 
 
 
  - Process Oriented SOA (민첩성 추가) : 복잡한 업무 프로세스들을 BPM 기반으로 구현하는 SOA.
 
    각 서비스를 조합하는 하는 것을 BPM으로 구현함으로써 업무의 조합이 별도 코딩 없이 BPM 툴로 이루어지고,
 
    업무프로세스가 바뀌었을 때 BPM 툴에서 업무프로세스를 조정하는 것만으로도 빠르게 비즈니스 요구사항에 대응할 수 있다.
 
 
 
 
 
  * 서비스 구현
 
  - EAI : 시스템 간의 통합을 목적으로 하는 솔루션. SOA와는 다르게 Tightly Coupled되고, IT시스템 간의 통합을 지원한다.
 
    SOA 통합에서 다루기 힘든 트랜잭션이나 보안에 대한 내용을 해결해 준다.
 
    EAI 솔루션에도 IT시스템 간의 연계 흐름을 정의하게 위해서 BPM이 사용된다. (IC-BPM, HC-BPM)
 
 
 
  - UDDI : SOA시스템에서 이미 개발된 서비스를 재사용하기 위해서 서비스를 검색할 수 있어야 하는데 웹서비스에서는 UDDI로 구현한다.
